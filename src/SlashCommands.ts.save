import {
  APIMessage,
  Message,
  Channel,
  Client,
  Guild,
  GuildMember,
  MessageEmbed,
  Snowflake
} from "discord.js";
import WOKCommands from ".";
import ISlashCommand from "./interfaces/ISlashCommand";
import {Interaction,
  InteractionApplicationCommandCallbackData,
  ApplicationCommandInteractionData,
  ApplicationCommandInteractionDataOption,
  InteractionResponse,InteractionCallbackType,
  EditWebhookMessage,
  ExecuteWebhook
} from "./types/Interaction";
class SlashCommands {
  private _client: Client;
  private _instance: WOKCommands;

  constructor(instance: WOKCommands, listen = true) {
    this._instance = instance;
    this._client = instance.client;

    if (listen) {
      // @ts-ignore
      this._client.ws.on("INTERACTION_CREATE", async (interaction:Interaction) => {
        const { member, data, guild_id, channel_id,type,user } = interaction;
        if(type===1){
          await this.createInteractionResponse(interaction,1)
          return;
        }
        // if ty√ºee !== 1 data is always present!!
        const Appdata:ApplicationCommandInteractionData=data!!;
        const { name, options } = Appdata;
        
        const command = name.toLowerCase();
        const guild = guild_id?this._client.guilds.cache.get(guild_id):undefined;
        const args = this.getArrayFromOptions(guild, options);
        const channel = channel_id?guild?.channels.cache.get(channel_id):undefined;
        interaction.channel_type=user?"DM":"GUILD";
        this.invokeCommand(interaction, command, args, member, guild, channel);
      });
    }
  }

  public async get(guildId?: string): Promise<ISlashCommand[]> {
    // @ts-ignore
    const app = this._client.api.applications(this._client.user.id);
    if (guildId) {
      app.guilds(guildId);
    }

    return await app.commands.get();
  }

  public async create(
    name: string,
    description: string,
    options: Object[] = [],
    guildId?: string
  ): Promise<Object> {
    // @ts-ignore
    const app = this._client.api.applications(this._client.user.id);
    if (guildId) {
      app.guilds(guildId);
    }

    return await app.commands.post({
      data: {
        name,
        description,
        options,
      },
    });
  }

  public async delete(commandId: string, guildId?: string): Promise<Buffer> {
    // @ts-ignore
    const app = this._client.api.applications(this._client.user.id);
    if (guildId) {
      app.guilds(guildId);
    }

    return await app.commands(commandId).delete();
  }

  // Checks if string is a user id, if true, returns a Guild Member object
  private getMemberIfExists(value: string , guild: any) {
    if (
      value &&
      typeof value === "string" &&
      value.startsWith("<@!") &&
      value.endsWith(">")
    ) {
      value = value.substring(3, value.length - 1);

      value = guild?.members.cache.get(value);
    }

    return value;
  }

  public getObjectFromOptions(
    guild: { members: { cache: any } },
    options?: [ApplicationCommandInteractionDataOption]
  ): Object {
    const args: { [key: string]: any } = {};
    if (!options) {
      return args;
    }

    for (const { name, value } of options) {
      args[name] = this.getMemberIfExists(value!!, guild);
    }

    return args;
  }

  public getArrayFromOptions(
    guild: { members: { cache: any } } | undefined,
    options?: [ApplicationCommandInteractionDataOption]
  ): string[] {
    const args: string[] = [];
    if (!options) {
      return args;
    }

    for (const { value } of options) {
      if(!value){
        break;
      }
      args.push(this.getMemberIfExists(value, guild));
    }

    return args;
  }

  public async createAPIMessage(
    interaction: Interaction,
    content: any
  ):Promise<object> {
    const { data, files } = await APIMessage.create(
      // @ts-ignore
      this._client.channels.resolve(interaction.channel_id),
      content
    )
      .resolveData()
      .resolveFiles();

    return { ...data, files };
  }

  public async getInteractionResponseByToken(application_id: Snowflake,token:string): Promise<Message> {
    // @ts-ignore
    return await this.getInteractionResponse({token,application_id})
  }
  public async deleteInteractionResponseByToken(application_id: Snowflake,token:string): Promise<Buffer> {
    // @ts-ignore
    return await this.deleteInteractionResponse({token,application_id})
  }

  private async createInteractionResponse(interaction: Interaction, type: InteractionCallbackType,data?: InteractionApplicationCommandCallbackData,ephemeral?:boolean): Promise<Buffer> {
    let Send:InteractionResponse={type}
    if(data&&ephemeral){
      data.flags=64;
    }
    Send.data=data;
    // @ts-ignore
    return await this._client.api
    // @ts-ignore
    .interactions(interaction.id, interaction.token)
    .callback.post({data:Send});
  }
  private async getInteractionResponse(interaction: Interaction): Promise<Message> {
    // @ts-ignore
    return await this._client.api
    // @ts-ignore
    .webhooks(interaction.application_id, interaction.token)
    .messages["@original"].get();
  }
  private async editInteractionResponse(interaction: Interaction, data: EditWebhookMessage): Promise<Message> {
    // @ts-ignore
    return await  this._client.api
   // @ts-ignore
    .webhooks(interaction.application_id, interaction.token)
    .messages["@original"].patch({data});
  }
  //ATTENTION, if the message is ephemeral you can't delete it, only the user who got the message can see and delete it!!
  private async deleteInteractionResponse(interaction: Interaction): Promise<Buffer> {
    // @ts-ignore
    return await this._client.api
    // @ts-ignore
    .webhooks(interaction.application_id, interaction.token)
    .messages["@original"].delete();
  }
  private async createFollowupMessage(interaction: Interaction, data:ExecuteWebhook,ephemeral?:boolean): Promise<Message> {
    if(data&&ephemeral){
      data.flags=64;
    }
    // @ts-ignore
    return await this._client.api
    // @ts-ignore
    .webhooks(interaction.application_id,interaction.token)
    .post({data});
  }
  private async editFollowupMessage(interaction: Interaction, data: EditWebhookMessage, message:Message): Promise<Message> {
    // @ts-ignore
    return await  this._client.api
   // @ts-ignore
    .webhooks(interaction.application_id, interaction.token)
    .messages(message.id).patch({data});
  }
  //ATTENTION, if the message is ephemeral you can't delete it, only the user who got the message can see and delete it!!
  private async deleteFollowupMessage(interaction: Interaction, message:Message): Promise<Buffer> {
    // @ts-ignore
    return await this._client.api
    // @ts-ignore
    .webhooks(interaction.application_id, interaction.token)
    .messages(message.id).delete();
  }

  public async invokeCommand(
    interaction: Interaction,
    commandName: string,
    options: object,
    member: GuildMember | undefined,
    guild: Guild | undefined,
    channel: Channel | undefined
  ): Promise<boolean> {
    const command = this._instance.commandHandler.getCommand(commandName);

    if (!command || !command.callback) {
      return false;
    }
    interaction.status={};
    interaction.loading = async ():Promise<Message>=>{
        let respond = await this.createInteractionResponse(interaction,5)
        interaction.status.loaded=true;
        let respondMessage = await this.getInteractionResponse(interaction)
        return respondMessage;
    }
    interaction.reply=async(data:InteractionApplicationCommandCallbackData | string):Promise<Message>=>{
      if(interaction.status.loaded){
        let DataToSend:EditWebhookMessage ;
        //TODO enable support for also passing an embed as data
        if (typeof data === "string") {
          DataToSend={content:data}
        }else{
          DataToSend=data
        }
        let respond = await this.editInteractionResponse(interaction,DataToSend)
        interaction.status.send=true;
        return respond;
      }else if(!interaction.status.send){
        let DataToSend:InteractionApplicationCommandCallbackData ;
         //TODO enable support for also passing an embed as data
        if (typeof data === "string") {
          DataToSend={content:data}
        }else{
          DataToSend=data
        }
        let respond = await this.createInteractionResponse(interaction,4,DataToSend)
        interaction.status.send=true;
        let respondMessage = await this.getInteractionResponse(interaction)
        return respondMessage;
      }else{
        console.error(
          `WOKCommands > Interaction "${interaction.id}" loaded and send the message already`
        );
        return Promise.reject(`WOKCommands > Interaction "${interaction.id}" loaded and send the message already`);
      }

    }
    interaction.followUpMessages={create:this.createFollowupMessage,delete:this.deleteFollowupMessage,edit:this.editFollowupMessage};

    let result = await command.callback({
      member,
      guild,
      channel,
      args: options,
      // @ts-ignore
      text: options.join ? options.join(" ") : "",
      client: this._client,
      instance: this._instance,
      interaction,
    });

    if(interaction.status.send){
      return true;
    }
    if(interaction.status.loaded){
      console.error(
        `WOKCommands > Command "${commandName}" used loading, but not send, thats a mi of old and new methods, switch fully to the new ones to fix this`
      );
      return false;
    }

    if (!result&&!interaction.status.send) {
      console.error(
        `WOKCommands > Command "${commandName}" didn't send anything, and didn't return a value as fallback action`
      );
      return false;
    }

    if (result) {
      console.warn(
        `WOKCommands > Command "${commandName}" returned something from the callback, this is deprecated and will be removed later on`
      );
    }

    let patch: InteractionApplicationCommandCallbackData = {}
    // Handle embeds
    if (typeof result === "object") {
      const embed = new MessageEmbed(result);
       // @ts-ignore
      patch.embeds = [(await this.createAPIMessage(interaction, embed))];
    }else{
      patch.content= result;
    }
    this.createInteractionResponse(interaction,4,patch,true)


    let mess = await this.createFollowupMessage(interaction,{content:"hellotest2"},true)
    //console.log("create 2",mess)
    await (new Promise(resolve => setTimeout(resolve, 10000)));
 
     let message2 = await this.editFollowupMessage(interaction,{content:"editet"},mess)
    //console.log("edit 3",message2)
    await (new Promise(resolve => setTimeout(resolve, 10000))); 

    let mess3 = await this.deleteFollowupMessage(interaction,message2);
    //console.log("delet 4",mess3)
 

    

    return true;
  }
}

export = SlashCommands;
